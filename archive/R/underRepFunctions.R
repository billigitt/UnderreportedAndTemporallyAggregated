generateIncidence <- function(day1I, trueWeeklyR, wDaily, PoissonOrRound, week1Method, reporting, probReported, trueP){
  
  #This function generates daily and weekly incidence under a renewal equation format.
  #The number of weeks in the simulation is implicity defined in the length of trueWeeklyR
  #The incidence can be generated by rounding the R_t*lambda value, or by randomly drawing from
  # a Poisson distribution with rate R_t*lambda.
  #The probReported input tells us what the probability of reporting is, and so once we have the 
  #true incidence, we can sample from a Binomial distribution to get the reported incidence.
  
  
  wDailyLength <- length(wDaily)
  
  totalWeeks <- length(trueWeeklyR)
  totalDays <- totalWeeks*trueP
  dailyI <- c(day1I, rep(0, totalDays-1))

  if (week1Method == "Simulate"){
  
  for (j in 2:trueP){
    
    daysConsidered <- min(wDailyLength, (j-1))
    
    if (PoissonOrRound == "P"){
    
    dailyI[j] <- rpois(1, trueWeeklyR[1]*wDaily[daysConsidered:1]%*%dailyI[(j-daysConsidered):(j-1)])
    
    }
    
    if (PoissonOrRound == "R"){
      
      dailyI[j] <- round(trueWeeklyR[1]*wDaily[daysConsidered:1]%*%dailyI[(j-daysConsidered):(j-1)])
    }
    
  }
    
  } else if (week1Method == "Multinomial") {
    
    dailyI[1:trueP] <- rmultinom(1, day1I, rep(1/trueP, trueP))
    
  } else if (week1Method == "Even") {
    
    dailyI[1:trueP] <- rep(day1I/trueP, trueP)
    
  }
  
  
  
  for (i in 2:totalWeeks){
    
    for (j in 1:trueP){
      
      currentDay <- (i-1)*trueP+j
      daysConsidered <- min(wDailyLength, (currentDay-1))
      
      if (PoissonOrRound == "P"){
      
      dailyI[(i-1)*trueP+j] <- rpois(1, trueWeeklyR[i]*wDaily[daysConsidered:1]%*%dailyI[(currentDay - daysConsidered):(currentDay-1)])
      
      }
      
      if (PoissonOrRound == "R"){
        
        dailyI[(i-1)*trueP+j] <- round(trueWeeklyR[i]*wDaily[daysConsidered:1]%*%dailyI[(currentDay - daysConsidered):(currentDay-1)])
      
      }
      
    }
  
  }
  

  weeklyI <- matrix(dailyI, nrow = trueP, ncol = totalWeeks)
  weeklyI <- colSums(weeklyI)
  
  if (reporting == "Exact"){
    
    reportedWeeklyI <- round(probReported*weeklyI)
    
  } else if (reporting == "Random"){
  
  reportedWeeklyI <- sapply(weeklyI, function(n) rbinom(1, size = n, prob = probReported))
  
  }
  
  output = list(weeklyI = weeklyI, dailyI = dailyI, reportedWeeklyI = reportedWeeklyI)
  
}

inferUnderRepR <- function(weeklyI, wP, priorRShapeAndScale, probReported, M, P){
  
  #wPMatrix <- do.call(rbind, rep(list(wP), times = M))
    
  lengthSerial <- length(wP)
  totalWeeks <- length(weeklyI)
  totalDays <- totalWeeks*P
  
  simI <- matrix(0, nrow = M, ncol = P*totalWeeks)
  simItmp <- simI
  #initialise by drawing from multinomial distribution
  maxVal <- round(100*weeklyI[1]/probReported) # this should be sufficiently large to consider plausible week 1 true incidences
  invBinPMF <- likeliCalcInvBin(weeklyI[1], probReported, maxVal)
  maxVal <- length(invBinPMF) #we need this line in case the maxVal ends up being too big!
  week1TrueIncSim <- sample(1:maxVal, size = M, prob = invBinPMF, replace = TRUE)
  simI[, 1:P] <- t(do.call(cbind, map(week1TrueIncSim, ~ generateMultinomialSamples(.x, rep(1/P, P), 1))))
  likelihood <- matrix(1, nrow = M, ncol = totalWeeks)
  rPosterior <- likelihood
  
  pb <- progress_bar$new(total = totalWeeks, width = 60)
  
  for (i in 2:totalWeeks){
    
    acceptance <- 0
    
    simIFresh <- matrix(0, nrow = M, ncol = P*totalWeeks)
    
    while (acceptance != M){
      
      #following if loop allows broader sampling from multinomial than if we just re-sample from initial batch.
      if (i==2){
       
      simItmp[, 1:P] <- t(do.call(cbind, map(week1TrueIncSim, ~ generateMultinomialSamples(.x, rep(1/P, P), 1))))
         
      } else {
        
      sampling <- sample(M, size = M, replace = TRUE, prob = likelihood[, i-1])
      simItmp <- simI[sampling, ]
      
      }
      
      rSampleTmp <- rgamma(M, shape = priorRShapeAndScale[1], scale = priorRShapeAndScale[2])
      
    for (j in 1:P){
      
      timeConsidered <- min(((i-1)*P+j-1), lengthSerial)
      if (timeConsidered!=1){
        
      #summation <- simItmp[, ((i-1)*P+j-timeConsidered):((i-1)*P+(j-1))]%*%wP[timeConsidered:1]
        matrix <- simItmp[, ((i-1)*P+j-timeConsidered):((i-1)*P+(j-1))]
        vector <- wP[timeConsidered:1]
        summation <- matrix_mult_cpp(matrix, vector)
      } else{
        summation <- simItmp[, ((i-1)*P+j-1)]*wP[1]
      }
      
      simItmp[, (i-1)*P+j] <- rpois(n = M, lambda = rSampleTmp*summation)
      #summand <- wPMatrix[, timeConsidered:1]*simItmp[, ((i-1)*P+j-timeConsidered):((i-1)*P+(j-1))]
      #simItmp[, (i-1)*P+j] <- mapply(rpois, n = 1, lambda = rSampleTmp*customSummation(summand, dim(summand)))
      # CAN WE REDUCE INDEING TO SPEED UP?
      #look at binomial vs choosing different values of rho
      
    }
    
    # Calculate what the weekly incidence total is, for the new batch of simulations a
    summand <- simItmp[, ((i-1)*P+1):(i*P)]
    weeklySimI <- customSummation(summand, dim(summand))
    likelihoodTmp <- dbinom(weeklyI[i], size = weeklySimI, prob = probReported)
    likelihoodTmp[is.na(likelihoodTmp)] <- 0
    likelihoodTmp[likelihoodTmp == Inf] <- 0
    if (sum(likelihoodTmp) == 0) {
      userResponse <- readline(sprintf("Looks like likelihoods are too small. Do you want to continue? (y/n) "))
      
      # Check the user's response
      if (tolower(userResponse) != 'y') {
        cat("Execution stopped by user.\n")
        break
      }
    }
    
    logicalAccept <- ((weeklySimI>=weeklyI[i]) & (likelihoodTmp>0))
    acceptanceNew <- sum(logicalAccept)
    
    if (acceptanceNew !=0){ #if number of new acceptances is 0, we just skip the updates and re-run.
    
    sampleVec <- 1:acceptanceNew
    
    if ((acceptance+ acceptanceNew)>M) {
      
      acceptanceNew <- M-acceptance
      sampleVec <- sample(1:sum(logicalAccept), size = acceptanceNew) #check
      
    }
    
    if (length(sampleVec) != 1){ #otherwise sampleVec stays the same
      
      sampleVec <- sample(sampleVec) #not strictly necessary if condition in if loop is used, but otherwise good to randomise order.
    
    }
    newSimI <- simItmp[logicalAccept, ] #remember, we now take the whole history as well as new part but currently this could include too many (more than M)
    rSampleTmp <- rSampleTmp[logicalAccept]
    likelihoodTmp <- likelihoodTmp[logicalAccept]
    if (sum(logicalAccept) != 1){
      
      newSimI <- newSimI[sampleVec, ] # this and sampleVec lines are used to make sure we sample randomly from the simulations that were accepted without biasing the matrix elements in any particular position.
      
    }
    
    rPosteriorNew <- rSampleTmp[sampleVec]
    newLikelihood <- likelihoodTmp[sampleVec]
    
    simIFresh[(acceptance+1):(acceptance+acceptanceNew), ] <- newSimI
    rPosterior[(acceptance+1):(acceptance+acceptanceNew), i] <- rPosteriorNew
    likelihood[(acceptance+1):(acceptance+acceptanceNew), i] <- newLikelihood
    
    }
    
    acceptance <- acceptance + acceptanceNew

    }
    
    simI <- simIFresh
    #To do: test-run. is everything working as we expect? need to add in likelihood... need to record the r values that worked.
    # do very simple example so we can track everything
    
    pb$tick()
    
  }
  
  means <- colSums(rPosterior*likelihood)/colSums(likelihood)
  means[1] <- NA
  
  cri <- matrix(NA, nrow = totalWeeks, ncol = 2)
  
  for (i in 2:totalWeeks){
    
    cri[i, ] <- Quantile(rPosterior[, i], weights = likelihood[, i], probs = c(0.025, 0.975), type = 5)
    
  }
  
  output <- list(rPosterior = rPosterior, likelihood = likelihood, means = means, cri = cri, simI = simI)
  
}

credibleCalc <- function(rCDF, rVals, ciThresh){
  
  upperThresh <- 0.01*(ciThresh + 0.5*(100-ciThresh))
  lowerThresh <- 0.01*0.5*(100-ciThresh)
  
  idxUpper <- min(which(rCDF>upperThresh)) - 1
  idxLower <- max(which(rCDF<lowerThresh))
  
  upperFrac <- (upperThresh - rCDF[idxUpper])/(rCDF[idxUpper+1] - rCDF[idxUpper])
  lowerFrac <- (lowerThresh - rCDF[idxLower])/(rCDF[idxLower+1] - rCDF[idxLower])
  
  upperExtra <- upperFrac*(rVals[idxUpper + 1] - rVals[idxUpper])
  upperFinal <- rVals[idxUpper] + upperExtra
  lowerExtra <- lowerFrac*(rVals[idxLower + 1] - rVals[idxLower])
  lowerFinal <- rVals[idxLower] + lowerExtra
  
  output <- c(lowerFinal, upperFinal)
  
  return(output)
  
}

likeliCalcInvBin <- function(x, rho, maxVal){
  
  #We need to calculate the probability that n takes various values. We do this from n = x to n = the MLE + numberOfStandDev * standard deviation (if n took the MLE) so that we get a reasonably large domain to look over

  nSupport <- x:maxVal
  prob <- rep(0, maxVal)
  for (n in nSupport){
    
    prob[n] <- choose(n,x)*rho^x*(1-rho)^(n-x)
    
  }
  #Need to get rid of probabilities so small they are 0, as once normalised will turn to NANs
  
  if ((all(prob == 0)) | (is.nan(sum(prob)))){
    
    error("Inverse Binomial PMF cannot be calculated. Incidence could be too large?")
    
  }
  
  prob <- prob/sum(prob)
  
}

generateMultinomialSamples <- function(n, probs, num_samples) {
  
  # This function is used to sample from a multinomial for multiple values of N. This is used in the initialisation step since we first sample from our inverseBinomial from I[1].
  rmultinom(num_samples, n, probs)
  
}

siCalc <- function(siGamPar, P, numWeeksToIntegrate, divisionsPerP){
  
  tol <- 1e-3
  
  stepSize <- 1/(P*divisionsPerP)
  totalDomain <- seq(from = 0, to = numWeeksToIntegrate+(1/P), by = stepSize)
  
  gamPdf <- dgamma(totalDomain, shape = siGamPar[1], scale = siGamPar[2])
  
  totalProb <- trapz(totalDomain, gamPdf)
  if (abs(totalProb-1)>tol){
    
    stop("Error: The value is not close enough to 1.")
    
  }
  
  wP <- rep(0, numWeeksToIntegrate*P)
  
  for (i in 1:(numWeeksToIntegrate*P)){
    
    tmpIdx <- ((i-1)*divisionsPerP+1):((i+1)*divisionsPerP+1)
    tmpDomain <- totalDomain[tmpIdx]
    wP[i] <- trapz(tmpDomain, gamPdf[tmpIdx]*tentFunction(i, P, tmpDomain))
    
  }
  
  wP[1] <- wP[1] + 1 - sum(wP)
  
  return(wP)
  
}

tentFunction <- function(k, P, u){
  
  return(1-P*abs(u-(k/P)))
  
}

customSummation <- function(summand, dimSummand){
  
  if (length(dimSummand) == 2){
    
    return(rowSums(summand))
    
  } else {
    
    return(summand)
    
  }
  
}

varianceCalc <- function(matrix){
  
  nrow <- nrow(matrix)
  sampleMeans <- colSums(matrix)/nrow
  sampleMeans <- do.call(rbind, rep(list(sampleMeans), times = nrow))
  SS <- colSums((matrix-sampleMeans)^2)
  var <- SS/(nrow-1)
  
  return(var)
  
}